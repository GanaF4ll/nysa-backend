generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum User_type {
  USER
  ORGANISATION
}

enum Sex {
  MALE
  FEMALE
  OTHER
}

enum Event_visibility {
  PUBLIC
  PRIVATE
  FRIENDSONLY
}

enum Member_status {
  PENDING
  ACCEPTED
  REFUSED
  LEFT
  KICKED
}

enum Message_status {
  SENT
  DELIVERED
  READ
}

enum Message_type {
  TEXT
  IMAGE
  VIDEO
  AUDIO
}

enum Notification_type {
  EVENT
  MESSAGE
  FRIEND_REQUEST
  ORGANISATION
}

// Table vérifiée lors de la connexion
// model Auth {
//   id                  String                @id @default(cuid())
//   email               String                @unique
//   password            String
//   type                Auth_type             @default(USER) @map("type")
//   created_at          DateTime              @default(now())
//   updated_at          DateTime              @updatedAt
//   // relation One to One
//   user                User?
//   organisation        Organisation?
//   // relation One to Many, un utilisateur peut être membre de plusieurs conversations
//   Conversation_member Conversation_member[]

//   Get_notification Get_notification[]
// }

// Table dans laquelle sont stockée les informations de l'utilisateur après connexion
model User {
  id         String    @id @default(cuid())
  type       User_type @default(USER) @map("type")
  email      String    @unique
  password   String?
  name       String?
  firstname  String?
  lastname   String?
  birthdate  DateTime?
  sex        Sex?      @map("sex")
  phone      String?
  image_url  String?
  bio        String?
  city       String?
  active     Boolean   @default(true)
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  Event_member        Event_member[]
  Message             Message[]
  Event               Event[]
  Conversation_member Conversation_member[]
  Get_notification    Get_notification[]
}

// 2e modèle de user, Table dans laquelle sont stockée les informations de l'organisation après connexion
// model Organisation {
//   auth_id    String   @id
//   name       String
//   image_url  String
//   bio        String
//   city       String
//   created_at DateTime @default(now())
//   updated_at DateTime @updatedAt

//   auth                Auth                  @relation(fields: [auth_id], references: [id])
//   // relation One to Many, une organisation peut avoir plusieurs membres
//   organisationMembers Organisation_member[]
// }

// Table de liaison entre les membres d'une organisation et l'organisation
// model Organisation_member {
//   organisation_id String
//   user_id         String

//   organisation Organisation @relation(fields: [organisation_id], references: [auth_id])
//   // ici, relation avec user directement plutôt qu'avec auth, car une orga ne peut pas faire partie d'une autre ?
//   user         User         @relation(fields: [user_id], references: [auth_id])

//   @@id([organisation_id, user_id]) // La clé primaire est la combinaison des deux champs, obligé d'avoir une clé primaire ici
// }

model Event {
  id               String           @id @default(cuid())
  creator_id       String
  title            String
  description      String
  date             DateTime         @db.Timestamp()
  // image_url   String  pour avoir une cover image 
  address          String
  // type POINT pas supporté par Prisma, on utilise deux champs pour stocker la latitude et la longitude ?
  latitude         Float
  longitude        Float
  max_participants Int
  visibility       Event_visibility @map("visibility")
  entry_fee        Float
  view_count       Int
  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt
  // relation One to Many, un évènement peut avoir plusieurs participants
  Event_member     Event_member[]
  // Conversation     Conversation?
  Event_images     Event_images[]
  user             User             @relation(fields: [creator_id], references: [id])
}

model Event_member {
  event_id String
  user_id  String
  status   Member_status @map("status")
  event    Event         @relation(fields: [event_id], references: [id])
  user     User          @relation(fields: [user_id], references: [id])

  @@id([event_id, user_id])
}

model Conversation {
  id         String   @id @default(cuid())
  name       String
  is_private Boolean  @default(true)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  Message             Message[]
  Conversation_member Conversation_member[]
}

model Message {
  id              String       @id @default(cuid())
  conversation_id String
  conversation    Conversation @relation(fields: [conversation_id], references: [id])
  sender_id       String
  sender          User         @relation(fields: [sender_id], references: [id])
  content         String
  status          String
  type            Message_type
  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt
}

model Conversation_member {
  conversation_id String
  user_id         String
  is_admin        Boolean @default(false)

  conversation Conversation @relation(fields: [conversation_id], references: [id])
  // relation avec Auth ou User en fonction de si une orga peut être membre d'une conversation
  user         User         @relation(fields: [user_id], references: [id])

  @@id([conversation_id, user_id])
}

model Notification {
  id               String             @id @default(cuid())
  target_id        String
  target_type      String
  type             Notification_type  @map("type")
  created_at       DateTime           @default(now())
  updated_at       DateTime           @updatedAt
  Get_notification Get_notification[]
}

// Pas sûr d'avoir capté le système de notification
model Get_notification {
  id              String   @id @default(cuid())
  notification_id String
  user_id         String
  content         String
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt

  user User @relation(fields: [id], references: [id])

  Notification Notification @relation(fields: [notification_id], references: [id])
}

model Event_images {
  id         String   @id @default(cuid())
  event_id   String
  url        String
  order      Int
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  Event Event @relation(fields: [event_id], references: [id])
}
